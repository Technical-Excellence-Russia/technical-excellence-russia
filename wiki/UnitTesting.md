# Unit-тест

Перевод статьи [Мартина Фаулера UnitTest](https://martinfowler.com/bliki/UnitTest.html)

О Unit-тестировании часто говорится при разработке программного обеспечения и с этим понятием я был знаком во время всего того времени, что я пишу программы. Однако, как и большинство технологий разработки, она очень плохо определена и я вижу путаницу, которая часто возникает когда люди думают что она более четко определена чем на самом деле.
![Unit Testing](img/ut-sketch.png)
Хотя я провел огромное количество unit-тестирований и ранее, моя окончательная позиция сформировалась когда я начал работать с Кентом Бэком и начал использовать семейство тестовых инструментов Xunit. (На самом деле, я иногда думаю хорошее название для этого стиля тестирования может быть "xunit-тестирование”.) Unit-тестирование также стало знаковой активностью Экстремального Программирования(XP) и быстро привело к TDD.

Были определенные сомнения про использование unit-тестирования в XP c самых ранних дней. Я четко помню обсуждения в usenet-группах в которых XPшники ругали эксперта по тестированию за неправильное использование понятия “модульный тест”. Мы спросили его про определение и он ответил что-то вроде “на моём тренинге в первый день я рассказываю про 24 разных определения модульного теста.”

Несмотря на различия есть некоторые общие элементы. В первую очередь, в том, что unit-тесты - низкоуровневые, фокусируются на маленькой части программной системы. Во-вторых, unit-тесты в наши дни пишутся самими разработчиками, используя свои обычные инструменты - единственное отличие в использовании определенного вида фреймворка[Я говорю “наши дни” потому, что определенно что-то изменилось из-за ХР. В начале столетия ХРшников жестко критиковали, так как существовало распространенное мнение, что разработчики не должны тестировать свой собственный код. Некоторые организации специализировались на unit-тестировании, их единственная задача была в написании unit-тестов, на код, написанный разработчиками. Причины этого были: у людей концептуальная слепота при тестировании собственного кода, разработчики - плохие тестировщики, и в том, что хорошо когда между разработчиками и тестировщиками есть здоровая конкуренция. Взгляд ХРшников был в том, что разработчики могут научиться быть эффективными тестировщиками, по крайней мере на уровне модульного тестирования и в том что когда вы вовлекаете отедельную группу цикл обратной связи, которую дают вам unit-тесты безнадежно длинный. Xunit сыграл здесь важную роль, он был спроектирован специально для того, чтобы минимизировать проблемы для разработчиков при написании тестов. ] для unit-тестирования. В-третьих, unit-тесты должны быть значительно быстрее чем другие виды тестов.

Итак, если есть общие элементы, то значит есть и различия. Одно отличие в том, что люди называют модулем(“unit”). Объектно-ориентированный дизайн стремится к использованию класса в качестве модуля, процедурные и функциональные подходы могут считать функцию в качестве модуля. Но на самом деле это зависит от ситуации - команда решает что имеет смысл считать модулем в целях их понимания системы и его тестирования. Хотя я начал с того, что модуль это класс я часто делаю набор тесно связанных классов и рассматриваю их как единый модуль. Редко я могу взять набор методов класса в качестве модуля. Как вы это определите, не имеет особого значения.

## Обособленный или коммуницирующий?

Более важное различие в том должен ли быть модуль который вы тестируете обособленным(solitary) или коммуницирующим(sociable) [Jay Fields пришел к терминам "solitary" and "sociable"]. Представьте что вы тестируете метод price класса order. Метод price должен запустить некоторые функции в классах product и customer. Если вы любите чтобы ваши тесты были обособленными, то вы не хотите использовать настоящие классы product или customer, потому, что ошибка в классе customer приведет к падению теста на класс order. Вместо этого вы используете Тестовые Дублёры для “соучастников”.

![Unit Testing](img/ut-isolate.png)

Однако, не все unit-тестировщики использую обособленные unit-тесты. На самом деле когда xunit-тестирование началось в 90х мы не делали попыток в сторону обособленных тестов пока взаимодействие не становилось затруднительным (таким как например, внешняя система для проверки кредитных карт). Мы не считали что сложно отследить реальную причину ошибки, даже если это станет причиной падения соседних тестов. Поэтому мы думали что позволив нашим тестам быть общительными не приведёт к проблемам на практике.

На самом деле, общительные тесты были одной из причин по которой нас критиковали за использование понятия “unit-тестирования”. Я считаю что понятие “unit-тестирование” подходящее потому, что эти тесты проверяют поведение одного модуля. Мы писали тесты предполагая что все остальное работает корректно.

По мере того как xunit-тестирование становилось более популярным в 2000х вернулось упоминание обособленных тестов, по крайней мере для некоторых людей. Мы видели восхождение Mock-объектов и фреймворков, поддерживающих подмену объектов(mocking). Были разработаны две школы xunit-фреймворков, которые я называю классическая и мок-школа. Одно из отличиев между двумя стилями в том что мокисты настаивают на обособленных unit-тестах, а классики предпочитают общительные тесты. Сегодня я знаю и уважаю xunit-тестировщиков обоих стилей (лично я остаюсь с классическим стилем).

Даже классические тестировщики как я, используют тестовые дублёры когда есть затруднительное взаимодействие. Они бесценны для того чтобы избавиться от недетерминированности при общении с удаленными сервисами. На самом деле, некоторые классические xunit-тестировщики также спорят должно ли каждое взаимодействие со внешними ресурсами такими как база данных или файловая система использовать тестовые дублеры. Частично это из-за риска недетерминированности, частично из-за скорости. Хотя я думаю что это хорошая рекомендация, я не считаю что использование дублеров для внешних ресурсов является абсолютным правилом. Если вы взаимодействуете со стабильным ресурсом и достаточно быстро для вас, то у вас нет причин не делать этого в ваших unit-тестах.

## Скорость

Обычное свойство unit-тестов - небольшой охват, выполняемый разработчиком собственноручно и высокая скорость - означает то, что они могут часто запускаться во время программирования. На самом деле, это одна из ключевых характеристик Самотестирующегося кода. В этой ситуации разработчики запускают unit-тесты несколько раз в минуту, каждый раз у нас есть код, который стоит того, чтобы его компилировать. Я это делаю, потому что я могу сломать что-то случайно, и я хочу сразу узнать об этом. Если я внес дефект во время моей  последней правки мне намного проще найти баг, потому, что не нужно слишком далеко заглядывать.

Когда вы запускаете unit-тесты настолько часто вы можете не запускать все unit-тесты. Обычно вам нужно запустить только те тесты которые проверяют ту частью кода, над которой вы сейчас работаете. Как обычно, это компромисс между глубиной тестирования и тем как долго занимает прогон тестов. Я называют такие тесты набором для компилирования (compile suite), тк это то, что я запускаю когда хочу скомпилировать, даже в интерпретируемых языках, таких как Ruby.

Если вы используете Непрерывную Интеграцию вы должны запускать тесты как часть этой практики. Довольно обычно при коммите прогонять набор тестов, который я называю набор для коммита, в него входят все unit-тесты. Также он может включать несколько более верхнеуровневых тестов. Как разработчику вам следует запускать этот набор для коммита несколько раз в день, естественно перед тем как размещать ваш коммит в систему контроля версий, но у вас также есть возможность в любое другое время запускать тесты - во время вашего перерыва или если вам необходимо пойти на встречу. Чем быстрее набор тестов, тем более часто вы сможете его запускать [если у вас есть полезные тесты, но на их запуск уходит больше времени чем бы вам хотелось, то вам следует создать deplyment-пайплайн и поместить более медленные тесты в более позднюю стадию этой трубы].

У разных людей есть разные стандарты по скорости unit-тестов и их тестовых наборов. Дэвид Хайнемейер Хэнссон доволен набором тестов для сборки, который пробегает несколько секунд и набором тестов для коммита который проходит за несколько минут. Гарри Бернхардт считает, что это невыносимо долго, настаивая на том, что при компиляции тесты должны пробежать примерно за 300мс, а Дэн Бодарт не хочет чтобы его коммит проходил более чем 10 секунд.
Я не думаю что есть абсолютно правильный ответ. Я лично не замечаю разницы между прогоном тестов меньше секунды или нескольких. Мне нравится золотое правило Кент Бэка что тесты при коммите не должны бегать более чему 10 минут. Но идея в том, чтобы ваши тесты должны выполняться достаточно быстро, так чтобы вы не разочаровывались при частом их запуске. И достаточно часто это так, чтобы когда вы обнаружите баг было бы достаточно маленький объем работы так, чтобы вы смогли быстро его найти.
